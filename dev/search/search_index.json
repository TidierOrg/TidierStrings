{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#tidierstrings","title":"TidierStrings","text":"<p>The goal of this package is to replicate the beauty of stringr from R in Julia in a way that works with Tidier or as a stand alone function.</p> <p>This package includes:</p> Category Function Matching <code>str_count</code>, <code>str_detect</code>, <code>str_locate</code>, <code>str_locate_all</code>, <code>str_replace</code>, <code>str_replace_all</code>, <code>str_remove</code>, <code>str_remove_all</code>, <code>str_split</code>, <code>str_starts</code>, <code>str_ends</code>, <code>str_subset</code>, <code>str_which</code> Concatenation <code>str_c</code>, <code>str_flatten</code>, <code>str_flatten_comma</code> Characters <code>str_dup</code>, <code>str_length</code>, <code>str_width</code>, <code>str_trim</code>, <code>str_squish</code>, <code>str_wrap</code>, <code>str_pad</code> Locale <code>str_equal</code>, <code>str_to_upper</code>, <code>str_to_lower</code>, <code>str_to_title</code>, <code>str_to_sentence</code>, <code>str_unique</code> Other <code>str_conv</code>, <code>str_like</code>, <code>str_replace_missing</code>, <code>word</code>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#index","title":"Index","text":"<ul> <li><code>TidierStrings.str_c</code></li> <li><code>TidierStrings.str_conv</code></li> <li><code>TidierStrings.str_count</code></li> <li><code>TidierStrings.str_detect</code></li> <li><code>TidierStrings.str_dup</code></li> <li><code>TidierStrings.str_ends</code></li> <li><code>TidierStrings.str_equal</code></li> <li><code>TidierStrings.str_extract</code></li> <li><code>TidierStrings.str_extract_all</code></li> <li><code>TidierStrings.str_flatten</code></li> <li><code>TidierStrings.str_flatten_comma</code></li> <li><code>TidierStrings.str_length</code></li> <li><code>TidierStrings.str_like</code></li> <li><code>TidierStrings.str_locate</code></li> <li><code>TidierStrings.str_locate_all</code></li> <li><code>TidierStrings.str_pad</code></li> <li><code>TidierStrings.str_remove</code></li> <li><code>TidierStrings.str_remove_all</code></li> <li><code>TidierStrings.str_replace</code></li> <li><code>TidierStrings.str_replace_all</code></li> <li><code>TidierStrings.str_replace_missing</code></li> <li><code>TidierStrings.str_squish</code></li> <li><code>TidierStrings.str_starts</code></li> <li><code>TidierStrings.str_subset</code></li> <li><code>TidierStrings.str_to_lower</code></li> <li><code>TidierStrings.str_to_sentence</code></li> <li><code>TidierStrings.str_to_title</code></li> <li><code>TidierStrings.str_to_upper</code></li> <li><code>TidierStrings.str_trim</code></li> <li><code>TidierStrings.str_trunc</code></li> <li><code>TidierStrings.str_unique</code></li> <li><code>TidierStrings.str_which</code></li> <li><code>TidierStrings.str_width</code></li> <li><code>TidierStrings.str_wrap</code></li> <li><code>TidierStrings.word</code></li> </ul>"},{"location":"reference/#reference-exported-functions","title":"Reference - Exported functions","text":"<p># <code>TidierStrings.str_c</code> \u2014 Method.</p> <pre><code>str_c(strings::AbstractVector; sep::AbstractString=\"\")\n</code></pre> <p>Joins a vector of strings into a single string.</p> <p>Arguments</p> <ul> <li><code>strings</code>: Input strings.</li> <li><code>sep</code>: The separator between the strings. Default is an empty string.</li> <li><code>collapse</code> : If provided, it joins the concatenated strings with the specified collapse string. If not, it returns an array of the concatenated strings.</li> </ul> <p>Returns The joined string.</p> <p>Examples</p> <pre><code>julia&gt; str_c([\"apple\", \"banana\", \"pear\", \"pineapple\"])\n\"applebananapearpineapple\"\n\njulia&gt; str_c([\"Michigan\", \"Maryland\"] , [\"MI\", \"MD\"], sep = \", \")\n2-element Vector{String}:\n \"Michigan, MI\"\n \"Maryland, MD\"\n\njulia&gt; str_c([\"Michigan\", \"Maryland\"] , [\"MI\", \"MD\"], sep = \", \", collapse =  \";   \")\n\"Michigan, MI;   Maryland, MD\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_conv</code> \u2014 Method.</p> <pre><code>str_conv(string::Union{String,Vector{UInt8}}, encoding::String)\n</code></pre> <p>Converts a string to a different encoding.</p> <p>Arguments</p> <ul> <li><code>string</code>: Input string.</li> <li><code>encoding</code>: A String that specifies the encoding to use.</li> </ul> <p>Returns The converted string.</p> <p>Examples</p> <pre><code>julia&gt; str_conv(\"Hello, World!\", \"UTF-8\")\n\"Hello, World!\"\n\njulia&gt; str_conv(\"Hello, World!\", \"ASCII\")\n\"Hello, World!\"\n\njulia&gt; str_conv(\"H\u00e9llo, W\u00f6rld!\", \"ISO-8859-1\")\n\"H\u00e9llo, W\u00f6rld!\"\n\njulia&gt; str_conv([0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2C, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21], \"UTF-8\")\n\"Hello, world!\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_count</code> \u2014 Method.</p> <pre><code>str_count(string::String, pattern::Union{String, Regex})\n</code></pre> <p>Count the number of non-overlapping occurrences of a pattern in a string.</p> <p>Arguments</p> <ul> <li><code>string</code>: The string in which to count the pattern.</li> <li><code>pattern</code>: A string or a regular expression to find within the string.</li> </ul> <p>The pattern can include special logic:</p> <p>Use | to represent \"or\" (e.g., \"red|blue\" counts any string that contains \"red\" or \"blue\"). Returns The count of non-overlapping occurrences of pattern in string. Examples</p> <pre><code>julia&gt; str_count(\"The blue sky is blue\", \"blue\")\n2\n\njulia&gt; str_count(\"The blue sky is blue\", r\"blu\")\n2\n\njulia&gt; str_count(\"The blue sky is blue\", \"blue|sky\")\n3\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_detect</code> \u2014 Method.</p> <pre><code>str_detect(string::String, pattern::Union{String, Regex})\n</code></pre> <p>Determine if a string contains a certain pattern.</p> <p>Arguments</p> <ul> <li><code>string</code>: The string to check.</li> </ul> <p>pattern: A string or a regular expression to find within the string. The pattern can include special logic:</p> <p>Use | to represent \"or\" (e.g., \"red|blue\" matches any string that contains \"red\" or \"blue\"). Use &amp; to represent \"and\" (e.g., \"red&amp;blue\" matches any string that contains both \"red\" and \"blue\"). Returns true if the string contains the pattern, false otherwise.</p> <p>Examples</p> <pre><code>julia&gt; str_detect(\"The sky is blue\", \"blue\")\ntrue\n\njulia&gt; str_detect(\"The sky is blue\", \"red\")\nfalse\n\njulia&gt; str_detect(\"The sky is blue\", r\"\bblu\b\")\nfalse\n\njulia&gt; str_detect(\"The sky is blue\", \"blue|red\")\ntrue\n\njulia&gt; str_detect(\"The sky is blue and the sun is red\", \"blue&amp;red\")\ntrue\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_dup</code> \u2014 Method.</p> <pre><code>str_dup(s::AbstractString, times::Int)\n</code></pre> <p>Duplicate the string <code>s</code> <code>times</code> times.</p> <p>Arguments</p> <ul> <li><code>s</code>: Input string.</li> <li><code>times</code>: Number of times to duplicate the string.</li> </ul> <p>Returns A string with the string <code>s</code> duplicated <code>times</code> times.</p> <p>Examples</p> <pre><code>julia&gt; str_dup(\"hello\", 3)\n\"hellohellohello\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_ends</code> \u2014 Method.</p> <pre><code>str_ends(string::String, pattern::Union{AbstractString, Regex}; negate::Bool=false)\n</code></pre> <p>Check if a string ends with a certain pattern.</p> <p>Arguments</p> <ul> <li><code>string</code>: Input string.</li> <li><code>pattern</code>: The pattern to check for. Can be a string or a regular expression.</li> <li><code>negate</code>: Whether to negate the result. Default is <code>false</code>.</li> </ul> <p>Returns A vector of booleans indicating if the string ends with the pattern.</p> <p>Examples</p> <pre><code>julia&gt; str_ends(\"apple pineapple\", r\"^p\")\nfalse\n\njulia&gt; str_ends.([\"apple\", \"banana\", \"pear\", \"pineapple\"], r\"e$\")  # [true, false, false, true]\n4-element BitVector:\n 1\n 0\n 0\n 1\njulia&gt; str_ends.([\"apple\", \"banana\", \"pear\", \"pineapple\"], r\"e$\", negate=true)  # [false, true, true, false]\n4-element BitVector:\n 0\n 1\n 1\n 0\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_equal</code> \u2014 Method.</p> <pre><code>str_equal(string::String, pattern::Union{String, Regex})\n</code></pre> <p>Check if a string exactly equals to a pattern, or for regular expressions, if the pattern can match the entire string.</p> <p>Arguments</p> <ul> <li><code>string</code>: The string to be checked.</li> <li><code>pattern</code>: The pattern to compare against. Can be a plain string or a Regex.</li> </ul> <p>Returns true if string equals to pattern (for plain strings) or if pattern can match the entire string (for Regex). false otherwise.</p> <p>Examples</p> <pre><code>julia&gt; str_equal(\"hello\", \"hello\")\ntrue\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_extract</code> \u2014 Method.</p> <pre><code>str_extract(string, pattern::Union{String, Regex})\n</code></pre> <p>Extract the first occurrence of a pattern from a string</p> <p>Arguments</p> <ul> <li><code>strings</code>: A string to search for matches.</li> <li><code>pattern</code>: The pattern to search for, either as a String or a Regex.</li> </ul> <p>Examples</p> <p>```jldoctest julia&gt; str_extract(\"hello world hello universe hello goodbye\", r\"hello\") \"hello\"</p> <p>julia&gt; str_extract.([\"hello world\", \"hello universe\", \"goodbye\"], \"hello\") 3-element Vector{Union{Missing, String}}:  \"hello\"  \"hello\"  missing  ```</p> <p>source</p> <p># <code>TidierStrings.str_extract_all</code> \u2014 Method.</p> <p>strextractall(strings, pattern::Union{String, Regex}; captures::Bool)</p> <p>Extract all occurrences of a pattern from a string</p> <p>Arguments</p> <ul> <li><code>strings</code>: A string to search for matches.</li> <li><code>pattern</code>: The pattern to search for, either as a String or a Regex.</li> <li><code>captures</code>: If true, return capture groups instead of the match.</li> </ul> <p>Examples</p> <p>```jldoctest julia&gt; strextractall(\"hello world hello universe hello goodbye\", r\"hello\") 3-element Vector{String}:  \"hello\"  \"hello\"  \"hello\"</p> <p>source</p> <p># <code>TidierStrings.str_flatten</code> \u2014 Function.</p> <pre><code>str_flatten(string::AbstractVector, collapse::AbstractString=\"\", last::Union{Nothing,AbstractString}=nothing; missing_rm::Bool=false)\n</code></pre> <p>Flatten a string vector into a single string.</p> <p>Arguments</p> <ul> <li><code>string</code>: Input string.</li> <li><code>collapse</code>: The string to insert between each string in the input vector. Default is <code>\"\"</code>.</li> <li><code>last</code>: The string to insert at the end of the flattened string. Default is <code>nothing</code>.</li> <li><code>missing_rm</code>: Remove <code>Missing</code> values from the input vector. Default is <code>false</code>.</li> </ul> <p>Returns A flattened string.</p> <p>Examples</p> <pre><code>julia&gt; str_flatten([\"a\", \"b\", \"c\"])\n\"abc\"\n\njulia&gt; str_flatten([\"a\", \"b\", \"c\", \"d\"])\n\"abcd\"\n\njulia&gt; str_flatten(['a', 'b', 'c'], \"-\")\n\"a-b-c\"\n\njulia&gt; str_flatten(['a', 'b', 'c'], \", \")\n\"a, b, c\"\n\njulia&gt; str_flatten(['a', 'b', 'c'], \", \", \" and \")\n\"a, b and c\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_flatten_comma</code> \u2014 Function.</p> <pre><code>str_flatten_comma(string::AbstractVector, last::Union{Nothing,AbstractString}=nothing; missing_rm::Bool=false)\n</code></pre> <p>Flatten a string vector into a single string, separated by commas.</p> <p>Arguments</p> <ul> <li><code>string</code>: Input string.</li> <li><code>last</code>: The string to insert at the end of the flattened string. Default is <code>nothing</code>.</li> <li><code>missing_rm</code>: Remove <code>Missing</code> values from the input vector. Default is <code>false</code>.</li> </ul> <p>Returns A flattened string.</p> <p>Examples</p> <pre><code>julia&gt; str_flatten_comma(['a', 'b', 'c'])\n\"a, b, c\"\n\njulia&gt; str_flatten_comma(['a', 'b'])\n\"a, b\"\n\njulia&gt; str_flatten_comma(['a', 'b'], \" and \")\n\"a and b\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_length</code> \u2014 Method.</p> <pre><code>str_length(s::AbstractString)\n</code></pre> <p>Return the length of the string <code>s</code>.</p> <p>Arguments</p> <ul> <li><code>s</code>: Input string.</li> </ul> <p>Returns The length of the string <code>s</code>.</p> <p>Examples</p> <pre><code>julia&gt; str_length(\"hello world! \ud83d\ude0a\")\n14\n\njulia&gt; str_length(\"\ud83d\ude0a\")\n1\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_like</code> \u2014 Method.</p> <pre><code>str_like(string, pattern::String; ignore_case::Bool = true)\n</code></pre> <p>Detect a pattern in each string of the input vector using SQL-like pattern matching.</p> <p>Arguments</p> <ul> <li><code>string</code>: Input string.</li> <li><code>pattern</code>: The pattern to check for. Can be a string or a regular expression.</li> <li><code>ignore_case</code>: Whether to ignore case when matching. Default is <code>true</code>.</li> </ul> <p>Returns A vector of booleans indicating if the string matches the pattern.</p> <pre><code>julia&gt; str_like(\"hello\", \"h_llo\")\ntrue\n\njulia&gt; str_like.([\"Hello\", \"world\", \"HELLO\", \"WORLD\"], \"H_llo\")\n4-element BitVector:\n 1\n 0\n 1\n 0\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_locate</code> \u2014 Method.</p> <pre><code>str_locate(string::AbstractString, pattern::Union{AbstractString, Regex})\n</code></pre> <p>Returns the index of the first occurrence of a pattern in a string.</p> <p>Arguments</p> <ul> <li><code>string</code>: Input string.</li> <li><code>pattern</code>: The pattern to search for. Can be a string or a regular expression.</li> </ul> <p>A tuple <code>(start, end)</code> where <code>start</code> is the position at the start of the match and <code>end</code> is the position of the end.</p> <p>Examples</p> <pre><code>julia&gt; fruit = [\"apple\", \"banana\", \"pear\", \"pineapple\"]; str_locate(fruit[1], \"e\")\n(5, 5)\n\njulia&gt; fruit = [\"apple\", \"banana\", \"pear\", \"pineapple\"]; str_locate(fruit[2], \"a\")\n(2, 2)\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_locate_all</code> \u2014 Method.</p> <pre><code>str_locate_all(string::AbstractString, pattern::Union{AbstractString, Regex})\n</code></pre> <p>Returns the indices of all occurrences of a pattern in a string.</p> <p>Arguments</p> <ul> <li><code>string</code>: Input string.</li> <li><code>pattern</code>: The pattern to search for. Can be a string or a regular expression.</li> </ul> <p>A vector of tuples <code>(start, end)</code> where <code>start</code> is the position at the start of the match and <code>end</code> is the position of the end.</p> <p>Examples</p> <pre><code>julia&gt; fruit = [\"apple\", \"banana\", \"pear\", \"pineapple\"]; str_locate_all(fruit[1], \"e\")\n1-element Vector{Tuple{Int64, Int64}}:\n (5, 5)\n\njulia&gt; fruit = [\"apple\", \"banana\", \"pear\", \"pineapple\"]; str_locate_all(fruit[2], \"a\")\n3-element Vector{Tuple{Int64, Int64}}:\n (2, 2)\n (4, 4)\n (6, 6)\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_pad</code> \u2014 Method.</p> <pre><code>str_pad(string::AbstractString, width::Integer; side::String=\"right\", pad::AbstractString=\" \", use_width::Bool=true)\n</code></pre> <p>Pad a string to a certain width.</p> <p>Returns</p> <p>The padded string.</p> <p>Arguments</p> <ul> <li><code>string</code>: The string to be padded.</li> <li><code>width</code>: The width to pad the string to.</li> <li><code>side</code>: The side to pad the string on. Can be \"left\", \"right\", or \"both\".</li> <li><code>pad</code>: The string to use for padding.</li> <li><code>use_width</code>: Whether to use the width argument or the length of the string.</li> </ul> <p>Examples</p> <pre><code>julia&gt; str_pad(\"hello\", 10)\n\"hello     \"\n\njulia&gt; str_pad(\"hello\", 10, side=\"left\")\n\"     hello\"\n\njulia&gt; str_pad(\"hello\", 10, side=\"both\")\n\"  hello   \"\n\njulia&gt; str_pad(\"hello\", 10, side=\"both\", pad=\"*\")\n\"**hello***\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_remove</code> \u2014 Method.</p> <pre><code>str_remove(string::String, pattern::Union{String, Regex})\n</code></pre> <p>Remove the first occurrence of the pattern in the string.</p> <p>Arguments</p> <ul> <li><code>string</code>: The string from which the pattern should be removed.</li> <li><code>pattern</code>: The pattern which should be removed from the string. Can be a string or a regular expression.</li> </ul> <p>Returns A string with the first occurrence of the pattern removed.</p> <p>Examples</p> <pre><code>julia&gt; string = \"I love tidier strings strings\"\n\"I love tidier strings strings\"\n\njulia&gt; str_remove(string, \" strings\")\n\"I love tidier strings\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_remove_all</code> \u2014 Method.</p> <pre><code>str_remove_all(string::String, pattern::Union{String, Regex})\n</code></pre> <p>Remove all occurrences of the pattern in the string.</p> <p>Arguments</p> <ul> <li><code>string</code>: The string from which the pattern should be removed.</li> <li><code>pattern</code>: The pattern which should be removed from the string. Can be a string or a regular expression.</li> </ul> <p>Returns A string with all occurrences of the pattern removed.</p> <p>Examples</p> <pre><code>julia&gt; string = \"I love tidier strings, I love tidier strings\"\n\"I love tidier strings, I love tidier strings\"\n\njulia&gt; str_remove_all(string, \" strings\")\n\"I love tidier , I love tidier \"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_replace</code> \u2014 Method.</p> <pre><code>str_replace(string::String, pattern::Union{String, Regex}, replacement::String)\n</code></pre> <p>Replace the first occurrence of a pattern in a string with a specified string.</p> <p>Arguments string: The string in which to replace the pattern. pattern: A string or a regular expression to find within the string. replacement: The string to insert in place of the pattern. The pattern can include special logic:</p> <p>Use | to represent \"or\" (e.g., \"red|blue\" matches any string that contains \"red\" or \"blue\"). Returns A new string with the first occurrence of the pattern replaced with the replacement. Examples</p> <pre><code>julia&gt; str_replace(\"I Think You Should Leave is a great show\", \" \", \"\")\n\"IThink You Should Leave is a great show\"\n\njulia&gt; str_replace(\"The sky is blue\", \"blue\", \"red\")\n\"The sky is red\"\n\njulia&gt; str_replace(\"The sky is blue\", r\"\bblu\b\", \"red\")\n\"The sky is blue\"\n\njulia&gt; str_replace(\"The sky is blue\", \"blue|sky\", \"red\")\n\"The red is blue\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_replace_all</code> \u2014 Method.</p> <pre><code>str_replace_all(String::String, pattern::Union{String, Regex}, replacement::String)\n</code></pre> <p>Replace all occurrences of a pattern in a string with a specified string.</p> <p>Arguments</p> <ul> <li><code>string</code>: The string in which to replace the pattern.</li> <li><code>pattern</code>: A string or a regular expression to find within the string.</li> </ul> <p>replacement: The string to insert in place of the pattern. The pattern can include special logic:</p> <p>Use | to represent \"or\" (e.g., \"red|blue\" matches any string that contains \"red\" or \"blue\"). Returns A new string with all occurrences of the pattern replaced with the replacement.</p> <p>Examples</p> <pre><code>julia&gt; str_replace_all(\"I Think You Should Leave is a great show\", \" \", \"\")\n\"IThinkYouShouldLeaveisagreatshow\"\n\njulia&gt; str_replace_all(\"The blue sky is blue\", \"blue\", \"red\")\n\"The red sky is red\"\n\njulia&gt; str_replace_all(\"The blue sky is blue\", r\"\bblu\b\", \"red\")\n\"The blue sky is blue\"\n\njulia&gt; str_replace_all(\"The blue sky is blue\", \"blue|sky\", \"red\")\n\"The red red is red\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_replace_missing</code> \u2014 Function.</p> <pre><code>str_replace_missing(string::AbstractVector{Union{Missing,String}}, replacement::String=\"missing\")\n</code></pre> <p>Replaces missing values in a vector with a specified string.</p> <p>Arguments</p> <ul> <li><code>string</code>: Input vector of strings.</li> <li><code>replacement</code>: The string to replace missing values with. Default is \"missing\".</li> </ul> <p>Returns The vector of strings with missing values replaced.</p> <p>Examples</p> <pre><code>julia&gt; str_replace_missing([\"apple\", missing, \"pear\", \"pineapple\"])\n4-element Vector{String}:\n \"apple\"\n \"missing\"\n \"pear\"\n \"pineapple\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_squish</code> \u2014 Method.</p> <pre><code>str_squish(string::String)\n</code></pre> <p>Squish a string, removing consecutive whitespace and replacing it with a single space, as well as removing leading and trailing whitespace.</p>"},{"location":"reference/#arguments-string-the-string-to-be-squished-returns-a-squished-version-of-string","title":"Arguments <code>string</code>: The string to be squished. Returns A squished version of string.","text":"<p>Examples</p> <pre><code>julia&gt; str_squish(\"  This    is a string   with   spaces   \")\n\"This is a string with spaces\"\n\njulia&gt; str_squish(\"  Leading and trailing spaces   \")\n\"Leading and trailing spaces\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_starts</code> \u2014 Method.</p> <pre><code>str_starts(string::String, pattern::Union{AbstractString, Regex}; negate::Bool=false)\n</code></pre> <p>Check if a string starts with a certain pattern.</p> <p>Arguments</p> <ul> <li><code>string</code>: Input string.</li> <li><code>pattern</code>: The pattern to check for. Can be a string or a regular expression.</li> <li><code>negate</code>: Whether to negate the result. Default is <code>false</code>.</li> </ul> <p>Returns A vector of booleans indicating if the string starts with the pattern.</p> <p>Examples</p> <pre><code>julia&gt; str_starts.([\"apple\", \"banana\", \"pear\", \"pineapple\"], r\"^p\")  # [false, false, true, true]\n4-element BitVector:\n 0\n 0\n 1\n 1\njulia&gt; str_starts.([\"apple\", \"banana\", \"pear\", \"pineapple\"], r\"^p\", negate=true)  # [true, true, false, false]\n4-element BitVector:\n 1\n 1\n 0\n 0\njulia&gt; str_starts(\"apple pineapple\", r\"^p\")\nfalse\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_subset</code> \u2014 Method.</p> <pre><code>str_subset(string::String, pattern::Union{String, Regex})\n</code></pre> <p>Subset a string based on the presence of pattern. If the pattern exists within the string, the function will return the original string. If the pattern is not found within the string, the function will return an empty string.</p> <p>Arguments</p> <ul> <li><code>string</code>: The string from which to extract the subset.</li> <li><code>pattern</code>: The pattern to search for within the string. Can be a plain string or a Regex.</li> </ul> <p>Returns The original string if the pattern is found within it, otherwise an empty string.</p> <p>Examples</p> <pre><code>julia&gt; str_subset(\"Hello world!\", \"world\")\n\"Hello world!\"\n\njulia&gt; str_subset(\"Hello world!\", \"universe\")\n\"\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_to_lower</code> \u2014 Method.</p> <pre><code>str_to_lower(s::AbstractString)\n</code></pre> <p>Convert all characters in a string to lower case.</p> <p>Arguments</p> <ul> <li><code>s</code>: Input string.</li> </ul> <p>Returns String with all characters converted to lower case. Examples</p> <pre><code>julia&gt; str_to_lower(\"Hello World!\")\n\"hello world!\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_to_sentence</code> \u2014 Method.</p> <pre><code>str_to_sentence(s::AbstractString)\n</code></pre> <p>Convert the first character of each sentence in a string to upper case.</p> <p>Arguments</p> <ul> <li><code>s</code>: Input string.</li> </ul> <p>Returns A string with the first character of each sentence converted to upper case.</p> <p>Examples</p> <pre><code>julia&gt; str_to_sentence(\"hello world!\")\n\"Hello world!\"\n\njulia&gt; str_to_sentence(\"a sentence mUst starT With A capital letter.\")\n\"A sentence must start with a capital letter.\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_to_title</code> \u2014 Method.</p> <pre><code>str_to_title(s::AbstractString)\n</code></pre> <p>Convert the first character of each word in a string to upper case.</p> <p>Arguments</p> <ul> <li><code>s</code>: Input string.</li> </ul> <p>Returns A string with the first character of each word converted to upper case.</p> <p>Examples</p> <pre><code>julia&gt; str_to_title(\"hello world!\")\n\"Hello World!\"\n\njulia&gt; str_to_title(\"This is a title\")\n\"This Is A Title\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_to_upper</code> \u2014 Method.</p> <pre><code>str_to_upper(s::AbstractString)\n</code></pre> <p>Convert all characters in a string to upper case.</p> <p>Arguments</p> <ul> <li><code>s</code>: Input string.</li> </ul> <p>Returns String with all characters converted to upper case. Examples</p> <pre><code>julia&gt; str_to_upper(\"Hello World!\")\n\"HELLO WORLD!\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_trim</code> \u2014 Function.</p> <pre><code>str_trim(s::AbstractString, side::String=\"both\")\n</code></pre> <p>Removes all whitespace from the string <code>s</code> on the left and right side, or on both sides if <code>side</code> is \"both\".</p> <p>Arguments</p> <ul> <li><code>s</code>: Input string.</li> <li><code>side</code>: The side(s) from which to remove whitespace. Can be \"left\", \"right\", or \"both\".</li> </ul> <p>Returns The string <code>s</code> with all whitespace removed on the left and right side, or on both sides if <code>side</code> is \"both\".</p> <p>Examples</p> <pre><code>julia&gt; str_trim(\"  hello world! \ud83d\ude0a  \")\n\"hello world! \ud83d\ude0a\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_trunc</code> \u2014 Method.</p> <p>str_trunc(string::AbstractString, width::Integer; side::String=\"right\", ellipsis::AbstractString=\"...\")</p> <p>Truncate a string to a fixed number of characters.</p> <p>Arguments</p> <ul> <li><code>string</code>: Input string to be truncated.</li> <li><code>width</code>: Maximum width of the resulting string, including the ellipsis.</li> <li><code>side</code>: Side from which to truncate. Can be \"right\", \"left\", or \"center\". Defaults to \"right\".</li> <li><code>ellipsis</code>: String to indicate content has been removed. Defaults to \"...\".</li> </ul> <p>Returns</p> <p>A truncated string of length less than or equal to <code>width</code>, including the ellipsis.</p> <p>Examples</p> <pre><code>julia&gt; str_trunc(\"This is a long string\", 10)\n\"This is...\"\n\njulia&gt; str_trunc(\"This is a long string\", 10, side=\"left\")\n\"...g string\"\n\njulia&gt; str_trunc(\"This is a long string\", 10, side=\"center\")\n\"Thi...ring\"\n\njulia&gt; str_trunc(\"Short\", 10)\n\"Short\"\n\njulia&gt; str_trunc(\"This is a long string that needs to be truncated\", 20, side = \"right\", ellipsis = \"--\")\n\"This is a long str--\"\n</code></pre> <p>source</p> <p>&lt;a id='TidierStrings.str_unique-Tuple{AbstractVector{&lt;:AbstractString}}' href='#TidierStrings.str_unique-Tuple{AbstractVector{&lt;:AbstractString}}'&gt;# <code>TidierStrings.str_unique</code> \u2014 Method.</p> <pre><code>str_unique(strings::AbstractVector{&lt;:AbstractString}; ignore_case::Bool=false)\n</code></pre> <p>Remove duplicates from a vector of strings.</p> <p>Arguments</p> <ul> <li><code>strings</code>: Input vector of strings.</li> <li><code>ignore_case</code>: Whether to ignore case when comparing strings. Default is <code>false</code>.</li> </ul> <p>Returns A vector of unique strings from the input vector.</p> <p>Examples</p> <pre><code>julia&gt; str_unique([\"apple\", \"banana\", \"pear\", \"banana\", \"Apple\"])\n4-element Vector{String}:\n \"apple\"\n \"banana\"\n \"pear\"\n \"Apple\"\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_which</code> \u2014 Method.</p> <pre><code>str_which(string::Vector{T}, pattern::Union{AbstractString, Regex}; negate::Bool=false)\n</code></pre> <p>Returns the indices of strings where there's at least one match to the pattern.</p> <p>Arguments</p> <ul> <li><code>string</code>: Input string.</li> <li><code>pattern</code>: The pattern to check for. Can be a string or a regular expression.</li> <li><code>negate</code>: Whether to negate the result. Default is <code>false</code>.</li> </ul> <p>Returns</p> <p>An integer vector containing indices of matching strings.</p> <p>Examples</p> <pre><code>julia&gt; str_which([\"apple\", \"banana\", \"pear\", \"pineapple\"], r\"a\")  # [1, 2, 3, 4]\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\njulia&gt; str_which([\"apple\", \"banana\", \"pear\", \"pineapple\"], r\"a\", negate=true)  # []\nInt64[]\njulia&gt; str_which([\"apple\", \"banana\", \"pear\", \"pineapple\"], \"a\", negate=true)  # []\nInt64[]\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_width</code> \u2014 Method.</p> <pre><code>str_width(s::AbstractString)\n</code></pre> <p>Return the width of the string <code>s</code>.</p> <p>Arguments</p> <ul> <li><code>s</code>: Input string.</li> </ul> <p>Returns The width of the string <code>s</code>.</p> <p>Examples</p> <pre><code>julia&gt; str_width(\"hello world! \ud83d\ude0a\")\n15\n\njulia&gt; str_width(\"\ud83d\ude0a\")\n2\n</code></pre> <p>source</p> <p># <code>TidierStrings.str_wrap</code> \u2014 Method.</p> <pre><code>str_wrap(string::AbstractString; width::Integer=80, indent::Integer=0, exdent::Integer=0, whitespace_only::Bool=true)::String\n</code></pre> <p>Wraps a string into multiple lines.</p> <p>Arguments</p> <ul> <li><code>string</code>: Input string.</li> <li><code>width</code>: The maximum width of each line. Default is 80.</li> <li><code>indent</code>: The number of spaces to indent each line. Default is 0.</li> <li><code>exdent</code>: The number of spaces to exdent each line. Default is 0.</li> <li><code>whitespace_only</code>: Whether to only wrap on whitespace. Default is true.</li> </ul> <p>Returns The wrapped string.</p> <p>Examples</p> <pre><code>julia&gt; println(str_wrap(\"This is an example text that should be wrapped based on the given width and breaking rules.\", width=20))\nThis is an example\ntext that should be\nwrapped based on the\ngiven width and\nbreaking rules.\n</code></pre> <p>source</p> <p># <code>TidierStrings.word</code> \u2014 Function.</p> <pre><code>word(string::AbstractString, start_index::Int=1, end_index::Int=start_index, sep::AbstractString=\" \")\n</code></pre> <p>Extract a word from a string.</p> <p>Arguments</p> <ul> <li><code>string</code>: Input string.</li> <li><code>start_index</code>: The starting index of the word. Default is 1.</li> <li><code>end_index</code>: The ending index of the word. Default is <code>start_index</code>.</li> <li><code>sep</code>: The separator between the start and end indices. Default is a space.</li> </ul> <p>Returns The extracted word from the string.</p> <p>Examples</p> <pre><code>julia&gt; word(\"Jane saw a cat\", 1)\n1-element Vector{SubString{String}}:\n \"Jane\"\n\njulia&gt; word(\"Jane saw a cat\", 2)\n1-element Vector{SubString{String}}:\n \"saw\"\n\njulia&gt; word(\"Jane saw a cat\", -1)\n1-element Vector{SubString{String}}:\n \"cat\"\n\njulia&gt; word(\"Jane saw a cat\", 2, -1)\n3-element Vector{SubString{String}}:\n \"saw\"\n \"a\"\n \"cat\"\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#reference-internal-functions","title":"Reference - Internal functions","text":""},{"location":"examples/generated/UserGuide/supported_functions/","title":"Supported Functions","text":"<pre><code>using Tidier\nusing TidierStrings\nusing DataFrames, Chain\n\ndf = DataFrame(\n  Names = [\"Alice\", \"Bob\", \"Charlie\", \"Dave\", \"Eve\", \"Frank\", \"Grace\"],\n  City = [\"New York        2019-20\", \"Los    \\n\\n\\n\\n\\n\\n    Angeles 2007-12 2020-21\", \"San Antonio 1234567890         \", \"       New York City\", \"LA         2022-23\", \"Philadelphia            2023-24\", \"San Jose               9876543210\"],\n  Occupation = [\"Doctor\", \"Engineer\", \"Final Artist\", \"Scientist\", \"Physician\", \"Lawyer\", \"Teacher\"],\n  Description = [\"Alice is a doctor in New York\",\n                 \"Bob is is is an engineer in Los Angeles\",\n                 \"Charlie is an artist in Chicago\",\n                 \"Dave is a scientist in Houston\",\n                 \"Eve is a physician  in Phoenix\",\n                 \"Frank is a lawyer in Philadelphia\",\n                 \"Grace is a teacher in San Antonio\"]\n)\n</code></pre> 7\u00d74 DataFrame RowNamesCityOccupationDescriptionStringStringStringString1AliceNew York        2019-20DoctorAlice is a doctor in New York2BobLos    \\n\\n\\n\\n\\n\\n    Angeles 2007-12 2020-21EngineerBob is is is an engineer in Los Angeles3CharlieSan Antonio 1234567890         Final ArtistCharlie is an artist in Chicago4Dave       New York CityScientistDave is a scientist in Houston5EveLA         2022-23PhysicianEve is a physician  in Phoenix6FrankPhiladelphia            2023-24LawyerFrank is a lawyer in Philadelphia7GraceSan Jose               9876543210TeacherGrace is a teacher in San Antonio <p>Support Regex: <code>str_detect</code>, <code>str_replace</code>, <code>str_replace_all</code>, <code>str_remove</code>, <code>str_remove_all</code> <code>str_count</code>, <code>str_equal</code>, <code>str_subset</code></p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/supported_functions/#str_squish","title":"<code>str_squish()</code>","text":"<p>Removes leading and trailing white spaces from a string and also replaces consecutive white spaces in between words with a single space. It will also remove new lines.</p> <pre><code>df = @chain df begin\n    @mutate(City = str_squish(City))\nend\n</code></pre> 7\u00d74 DataFrame RowNamesCityOccupationDescriptionStringStringStringString1AliceNew York 2019-20DoctorAlice is a doctor in New York2BobLos Angeles 2007-12 2020-21EngineerBob is is is an engineer in Los Angeles3CharlieSan Antonio 1234567890Final ArtistCharlie is an artist in Chicago4DaveNew York CityScientistDave is a scientist in Houston5EveLA 2022-23PhysicianEve is a physician  in Phoenix6FrankPhiladelphia 2023-24LawyerFrank is a lawyer in Philadelphia7GraceSan Jose 9876543210TeacherGrace is a teacher in San Antonio <p></p> <p></p>"},{"location":"examples/generated/UserGuide/supported_functions/#str_replace-str_replace_all","title":"<code>str_replace()</code>, <code>str_replace_all</code>","text":"<p>Replaces the first occurrence of a pattern in a string with a specified text. Takes a string, pattern to search for, and the replacement text as arguments. It also supports the use of regex and logical operator | . This is in contrast to <code>str_replace_all()</code> which will replace each occurence of a match within a string.</p> <pre><code>@chain df begin\n  @mutate(City = str_replace(City, r\"\\s*20\\d{2}-\\d{2,4}\\s*\", \" ####-## \"))\n  #@mutate(Occupation = str_replace_all(Occupation, \"Doctor | Physician \", \"Doctor\"))\n  @mutate(Description = str_replace(Description, \"is | a\", \"4 \"))\n\nend\n</code></pre> 7\u00d74 DataFrame RowNamesCityOccupationDescriptionStringStringStringString1AliceNew York ####-## DoctorAlice 4 a doctor in New York2BobLos Angeles ####-## 2020-21EngineerBob 4 is is an engineer in Los Angeles3CharlieSan Antonio 1234567890Final ArtistCharlie 4 an artist in Chicago4DaveNew York CityScientistDave 4 a scientist in Houston5EveLA ####-## PhysicianEve 4 a physician in Phoenix6FrankPhiladelphia ####-## LawyerFrank 4 a lawyer in Philadelphia7GraceSan Jose 9876543210TeacherGrace 4 a teacher in San Antonio <p></p> <p></p>"},{"location":"examples/generated/UserGuide/supported_functions/#str_remove-str_remove_all","title":"<code>str_remove()</code>, <code>str_remove_all()</code>","text":"<p>These functions will remove the first occurence or all occurences of a match, respectively.</p> <pre><code>@chain df begin\n    @mutate(split = str_remove_all(Description, \"is\"))\nend\n</code></pre> 7\u00d75 DataFrame RowNamesCityOccupationDescriptionsplitStringStringStringStringString1AliceNew York 2019-20DoctorAlice is a doctor in New YorkAlice a doctor in New York2BobLos Angeles 2007-12 2020-21EngineerBob is is is an engineer in Los AngelesBob an engineer in Los Angeles3CharlieSan Antonio 1234567890Final ArtistCharlie is an artist in ChicagoCharlie an artt in Chicago4DaveNew York CityScientistDave is a scientist in HoustonDave a scientt in Houston5EveLA 2022-23PhysicianEve is a physician  in PhoenixEve a physician in Phoenix6FrankPhiladelphia 2023-24LawyerFrank is a lawyer in PhiladelphiaFrank a lawyer in Philadelphia7GraceSan Jose 9876543210TeacherGrace is a teacher in San AntonioGrace a teacher in San Antonio <p></p> <p></p>"},{"location":"examples/generated/UserGuide/supported_functions/#str_detect","title":"<code>str_detect()</code>","text":"<p>Checks if a pattern exists in a string. It takes a string and a pattern as arguments and returns a boolean indicating the presence of the pattern in the string. This can be used inside of <code>@filter</code>, <code>@mutate</code>, <code>if_else()</code> and <code>case_when()</code>. <code>str_detect</code> supports logical operators <code>|</code> and <code>&amp;</code>. <code>case_when()</code> with <code>filter()</code> and <code>str_detect()</code>.</p> <pre><code>@chain df begin\n    @mutate(Occupation = if_else(str_detect(Occupation, \"Doctor | Physician\"), \"Physician\", Occupation))\n    @filter(str_detect(Description, \"artist | doctor\"))\nend\n</code></pre> 2\u00d74 DataFrame RowNamesCityOccupationDescriptionStringStringStringString1AliceNew York 2019-20PhysicianAlice is a doctor in New York2CharlieSan Antonio 1234567890Final ArtistCharlie is an artist in Chicago <p>and</p> <pre><code>@chain df begin\n    @mutate(state = case_when(str_detect(City, \"NYC | New York\") =&gt; \"NY\",\n        str_detect(City, \"LA | Los Angeles | San &amp; Jose\") =&gt; \"CA\", true =&gt; \"other\"))\nend\n</code></pre> 7\u00d75 DataFrame RowNamesCityOccupationDescriptionstateStringStringStringStringString1AliceNew York 2019-20DoctorAlice is a doctor in New YorkNY2BobLos Angeles 2007-12 2020-21EngineerBob is is is an engineer in Los AngelesCA3CharlieSan Antonio 1234567890Final ArtistCharlie is an artist in Chicagoother4DaveNew York CityScientistDave is a scientist in HoustonNY5EveLA 2022-23PhysicianEve is a physician  in PhoenixCA6FrankPhiladelphia 2023-24LawyerFrank is a lawyer in Philadelphiaother7GraceSan Jose 9876543210TeacherGrace is a teacher in San AntonioCA <p></p> <p></p>"},{"location":"examples/generated/UserGuide/supported_functions/#str_equal","title":"<code>str_equal()</code>","text":"<p>Checks if two strings are exactly the same. Takes two strings as arguments and returns a boolean indicating whether the strings are identical.</p> <pre><code>@chain df begin\n    @mutate(Same_City = case_when(str_equal(City, Occupation) =&gt; \"Yes\", true =&gt; \"No\"))\nend\n</code></pre> 7\u00d75 DataFrame RowNamesCityOccupationDescriptionSame_CityStringStringStringStringString1AliceNew York 2019-20DoctorAlice is a doctor in New YorkNo2BobLos Angeles 2007-12 2020-21EngineerBob is is is an engineer in Los AngelesNo3CharlieSan Antonio 1234567890Final ArtistCharlie is an artist in ChicagoNo4DaveNew York CityScientistDave is a scientist in HoustonNo5EveLA 2022-23PhysicianEve is a physician  in PhoenixNo6FrankPhiladelphia 2023-24LawyerFrank is a lawyer in PhiladelphiaNo7GraceSan Jose 9876543210TeacherGrace is a teacher in San AntonioNo <p></p> <p></p>"},{"location":"examples/generated/UserGuide/supported_functions/#str_to_upper-str_to_lower","title":"<code>str_to_upper()</code>, <code>str_to_lower()</code>","text":"<p>These will take a string and convert it to all uppercase or lowercase</p> <pre><code>@chain df begin\n    @mutate(Names = str_to_upper(Names))\nend\n</code></pre> 7\u00d74 DataFrame RowNamesCityOccupationDescriptionStringStringStringString1ALICENew York 2019-20DoctorAlice is a doctor in New York2BOBLos Angeles 2007-12 2020-21EngineerBob is is is an engineer in Los Angeles3CHARLIESan Antonio 1234567890Final ArtistCharlie is an artist in Chicago4DAVENew York CityScientistDave is a scientist in Houston5EVELA 2022-23PhysicianEve is a physician  in Phoenix6FRANKPhiladelphia 2023-24LawyerFrank is a lawyer in Philadelphia7GRACESan Jose 9876543210TeacherGrace is a teacher in San Antonio <p></p> <p></p>"},{"location":"examples/generated/UserGuide/supported_functions/#str_subset","title":"<code>str_subset()</code>","text":"<p>Returns the subset of strings that match a pattern. Takes a vector of strings and a pattern as arguments and returns all elements of a string that contains the pattern.</p> <pre><code>@chain df begin\n    @mutate(split = str_subset(Description, \"artist\"))\nend\n</code></pre> 7\u00d75 DataFrame RowNamesCityOccupationDescriptionsplitStringStringStringStringString1AliceNew York 2019-20DoctorAlice is a doctor in New York2BobLos Angeles 2007-12 2020-21EngineerBob is is is an engineer in Los Angeles3CharlieSan Antonio 1234567890Final ArtistCharlie is an artist in ChicagoCharlie is an artist in Chicago4DaveNew York CityScientistDave is a scientist in Houston5EveLA 2022-23PhysicianEve is a physician  in Phoenix6FrankPhiladelphia 2023-24LawyerFrank is a lawyer in Philadelphia7GraceSan Jose 9876543210TeacherGrace is a teacher in San Antonio <p>This page was generated using Literate.jl.</p>"}]}